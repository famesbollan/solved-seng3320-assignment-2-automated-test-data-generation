Download Link: https://assignmentchef.com/product/solved-seng3320-assignment-2-automated-test-data-generation
<br>



<ol>

 <li><strong> Fuzz Testing </strong></li>

</ol>

Fuzz Testing (random testing) is commonly used to discover software crashes through a large amount of randomly generated data. It is a cost-effective alternative to more systematic testing techniques. In this assignment, you are to apply fuzz testing to test a KWIC program. The KWIC (Key Word In Context) problem is defined as follows:

—————————————————————————————

“The KWIC [Key Word in Context] index system accepts an ordered set of lines; each line is an ordered set of words, and each word is an ordered set of characters. Any line may be “circularly shifted” by repeatedly removing the first word and appending it at the end of the line. The KWIC index system outputs a list of all circular shifts of all lines in alphabetical order.”




The KWIC system is a real system and is widely used in keyword in context indexes for libraries.

<strong><em> </em></strong>

<strong><em>Example </em></strong>

Consider the following three book titles (lines):

<ul>

 <li>Pattern-Oriented Software Architecture</li>

 <li>Software Architecture</li>

 <li>Introducing Design Patterns</li>

</ul>




The KWIC system produces the following output:

<ul>

 <li>Architecture Software</li>

 <li>Architecture Pattern-Oriented Software</li>

 <li>Design Patterns Introducing</li>

 <li>Introducing Design Patterns</li>

 <li>Patterns Introducing Design</li>

 <li>Pattern-Oriented Software Architecture</li>

 <li>Software Architecture Pattern-Oriented</li>

 <li>Software Architecture</li>

</ul>




Users can now quickly search for book titles that contain phrases such as “Software Architecture” or “Design Pattern”.

—————————————————————————————




For this assignment, you are given a Java implementation of the KWIC problem (KWIC.class), which can be found in Blackboard. The usage of this program is: <em>java KWIC input.txt </em>

where input.txt is a plain text file containing the input book titles (each line is a title).




You are required to apply fuzz testing to generate test input to crash the given KWIC program.

More specifically, you are required to:

<ul>

 <li>Develop a fuzz testing tool, which can feed a large amount of random data (random book titles such as “a8h h19%p”) to the KWIC program in an attempt to make it crash.</li>

 <li>Perform the fuzz testing, record the number of unique crashes (i.e., crashes with different exception messages at different program locations/line numbers) and the test input that crashes the program.</li>

 <li>Write a test report, which describes the test tool design, test environment, example of test cases, and summary of test results (especially the number of unique crashes detected).</li>

</ul>

<strong> </strong>

The marks will be distributed as follows:

<table width="513">

 <tbody>

  <tr>

   <td width="347">Fuzz tool development</td>

   <td width="166">10 marks</td>

  </tr>

  <tr>

   <td width="347">Fuzzing testing of the KWIC program</td>

   <td width="166">20 marks</td>

  </tr>

  <tr>

   <td width="347">Test report</td>

   <td width="166">10 marks</td>

  </tr>

 </tbody>

</table>




<ol start="2">

 <li><strong> Automated Testing Techniques </strong></li>

</ol>

In this assignment, you are to experiment with symbolic execution, mutation testing, and fuzz testing techniques. For symbolic execution, you are to experiment with KLEE, a symbolic execution tool for C programs. More specifically, you will:

<ul>

 <li>Symbolic execution: a) Download and install the KLEE tool from <a href="https://klee.github.io/">http://klee.github.io/</a><a href="https://klee.github.io/">;</a></li>

</ul>

<ol>

 <li>b) Apply KLEE to generate test data for the Triangle program as shown below.</li>

</ol>

<ul>

 <li>Compute the control-flow coverage of the test data generated by KLEE, including statement, branch decision coverage, condition coverage, condition/decision coverage, and multiple condition coverage.</li>

 <li>Fuzz testing: apply fuzz testing to generate test data for the Triangle program, compare the test results of fuzz testing and symbolic execution (in terms of the control-flow coverage achieved and the time spent).</li>

 <li>Mutation testing: apply at least two mutation operators to the Triangle program, and perform mutation testing. a) Mutate the Triangle code using the two mutation operators you selected. At least 10 mutants should be generated. The mutation can be done manually (by hand) or automatically (by developing a simple mutation tool); b) Perform mutation testing with the test cases generated by symbolic execution; and c) Measure the number of mutants being killed by the test cases. If some mutants are not killed, add more test cases to kill the mutants.</li>

 <li>Write a test report for this experiment. The test report should describe your experimental design, steps, and results.</li>

</ul>




<table width="617">

 <tbody>

  <tr>

   <td width="617"><em>/* The Triangle program, which determines if three inputs specify an equilateral triangle, an isosceles triangle, an ordinary triangle, or non-triangle. */ </em><em> </em><strong>void triangle </strong>(<strong>int </strong>a, <strong>int </strong>b, <strong>int </strong>c){if ((a+b&gt;c)&amp;&amp;(a+c&gt;b)&amp;&amp;(b+c&gt;a)) {     if (a==b || a==c || b==c) {         if (a==c &amp;&amp; a==b)printf(“equilateral triangle .
”);         else if (a==c||b==c)printf(“isosceles triangle.
”);}     elseprintf(“triangle.
”);} elseprintf(“non-triangle.
”); return;}</td>

  </tr>

 </tbody>

</table>




The marks will be distributed as follows: